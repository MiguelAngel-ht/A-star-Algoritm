# -*- coding: utf-8 -*-
"""AI Search Project.ipynb

Automatically generated by Colaboratory.


---
---

# **A-star Algorithm**

---
---

"""

def new_childs(a):
  """
  args:
          a    ->  STR string with value that probabitly follows the grammar
  returns:
        vector ->  LIST con todas las combinaciones simples posibles 
  """

  vector = []

  # FOR for one only character to change
  for i, j in enumerate(a):

    if j == 'a':
      aux = a[:i] + 'c' + a[i+1:] 
      vector.append(aux)
    elif j == 'c':
      aux = a[:i] + 'b' + a[i+1:]
      vector.append(aux)

  # FOR for 2 characters to change
  for i, j in enumerate([a[i:i+2] for i in range(len(a)-1)]):

    if j == 'bc':
      aux = a[:i] + 'S' + a[i+2:]
      vector.append(aux)

    if j == 'SS':
      aux = a[:i] + 'S' + a[i+2:]
      vector.append(aux)

    if j == 'ab':
      aux = a[:i] + 'a' + a[i+2:]
      vector.append(aux)

    if j == 'bc':
      aux = a[:i] + 'c' + a[i+2:]
      vector.append(aux)

    if j == 'ab':
      aux = a[:i] + 'bc' + a[i+2:]
      vector.append(aux)

    if j == 'bc':
      aux = a[:i] + 'ab' + a[i+2:]
      vector.append(aux)
    
  return vector

# testing function
new_childs('abca')

from queue import PriorityQueue

"""
      Source of base code: https://www.simplifiedpython.net/a-star-algorithm-python-tutorial/
"""

# creating base class
class state(object):
    def __init__(self, value, parent, start = 0, goal = 0):
        self.children = []
        self.parent = parent
        self.value = value
        self.dist = 0
        # Initialized values by default
        if parent:
            self.start = parent.start
            self.goal = parent.goal
            self.path = parent.path[:]
            self.path.append(value)
        else:
            self.path = [value]
            self.start = start
            self.goal = goal

    # method to know what is the sortest distance to the goal
    def get_distance(self):
        pass

    def create_children(self):
        pass

# Creating subclass
class state_string(state):
    def __init__(self, value, parent, start = 0, goal = 0):
        super(state_string, self).__init__(value, parent, start, goal)
        self.dist = self.get_distance()
 

    def get_distance(self):
            if self.value == self.goal:
                return 0
            dist = 0
            for i in range(len(self.value)):
                letter = self.value[i]
                # compute distance of every value of the state and sum all
                dist += abs(self.value.rfind(letter)-i-3)
            return dist
 
    def create_children(self):
            if not self.children:
              for child in new_childs(self.value):
                # append every string created with the function new_childs
                self.children.append(state_string(child, self))

# Creating a class that hold the final magic
class A_star_solver:
    def __init__(self, start, goal):
        # initilized values to the solver
        self.path = []
        self.vistedQueue =[]
        self.priorityQueue = PriorityQueue()
        self.start = start
        self.goal = goal

    def solve(self):
        # initilized class with the data structure
        start_state = state_string(self.start, 0, 
                                  self.start, self.goal)
 
        count = 0
        # data with priority assigned
        self.priorityQueue.put((0, count, start_state))

        while(not self.path and self.priorityQueue.qsize()):
               # get closest childs
               closeset_child = self.priorityQueue.get()[2]
               closeset_child.create_children()
               self.vistedQueue.append(closeset_child.value)
               
               # evaluate every child with another priority
               for child in closeset_child.children:

                   if child.value not in self.vistedQueue:
                      count += 1

                      if not child.dist:
                        self.path = child.path
                        break

                      self.priorityQueue.put((child.dist,count,child))

        # if there is not a path, is impossible
        if not self.path:
            print("Goal Of  is not possible !" + self.goal )

        return self.path

from queue import LifoQueue

class depth_first_search_solver:
    def __init__(self, start, goal):
        self.path = []
        self.vistedQueue =[]
        self.priorityQueue = PriorityQueue()
        self.start = start
        self.goal = goal

    ## solver
    def DFS(self):
        start = self.start
        closed = []                 # init open, closed
        open = LifoQueue()
        open.put(start)

        while not open.empty():        # loop until no more open states

            state = open.get()         # get next state to expand

            if state not in closed:    # prune?

                closed.append(state)   # mark state visited (closed)

                if state == 'S':     # success?
                    return True

                for child in new_childs(state):
                  open.put(child)                 # new states are open

        return False              # goal not found

"""---
---

# **Depth-Firts Search**

---
---

"""

def print_state(state):
    """Pretty-prints a state"""
    for row in state[0]:
        print(row)

import copy

def create_path(first_state=None):
    """Create a new empty or singleton path. If first_state has a value, it
    becomes the first state in the path."""
    if first_state == None:
        return []
    return [first_state]

def add_state_to_path(path, state):
    """Paths should be immutable, so this method performs a deep copy of
    the given path, appends the state to the copy, and returns the copy"""
    new_path = copy.deepcopy(path)
    new_path.append(state)
    return new_path

def print_path(path):
    """Relies on a print_state method to pretty-print a path."""
    print("Depth-First Search")
    print('============')
    for ste in path:
        print(ste)
    print(len(path)-1," Moves \n")

## solver
def DFS(start_state):
    closed = []                 # init open, closed
    open = LifoQueue()
    open.put(start_state)

    while not open.empty():        # loop until no more open states

        state = open.get()         # get next state to expand

        if state not in closed:    # prune?

            closed.append(state)   # mark state visited (closed)

            if state == 'S':     # success?
                return closed, True

            for new_state in new_childs(state):    # expand state
                open.put(new_state)                 # new states are open

    return closed, False              # goal not found

"""---
---

# **Main Functions**

---
---
"""

## run the solver no-path
def main_DFS(start_state):
  result = False
  path = create_path(start_state) 
  tol = len(start_state)*1000
  k = 0
  while (not result) and (k < tol):
    closed, result = DFS(start_state)
    k += 1
  if closed == 'S' or closed[-1] == 'S':
    for ste in closed[1:]:
      path = add_state_to_path(path, ste)
    print_path(path)
  else:
    print('There is not possible')

# Calling all the existing stuffs
def main_Astar(start1):
    goal1 = "S"
    a = A_star_solver(start1, goal1)
    a.solve()

    if a.path != None and a.path != []:

      print("A* Algorithm")
      print('============')

      for i in range(len(a.path)):
          print(a.path[i])
          
      print(len(a.path)-1,' Moves')

start = 'acba'
main_DFS(start)
main_Astar(start)
